1. 
//构建RAG，确定node之间edge的关系，但是不用确定edge weight；同时确定每个node histogram。下面有具体的程序和rag class interface
g=constructRAG(slicLabel,fhLabel,img,binNum);

2. 
//获得edge array这样一个数组
for edge in g.allEdge():
	src=edge[0]；
	dst=edge[1]；
	purity_before=两个region合并之前histogram entropy的均值；
	把两个RAG node 的histogram的bin由数值，转换为频率（为了防止一块区域过大，一块区域过小，区域过小的部分entropy作用被忽略）；
	newHist=两个bin为频率的histogram相加
	purity_after=entropy(newHist)
	purity_loss=purity_after-purity_before
	ragEdge.src=src
	ragEdge.dst=dst
	ragEdge.weight=purity_loss
	edgeArray.pushBack(ragEdge)

3. 
//把edgeArray变为heap
heapArray=heapify(edgeArray)

4. 
//最后融合
while superpixelNum>userInputNum and heap>0:
	src=heapArray[0].src
	dst=heapArray[0].dst
	//找到两个node 现在是否在一个大RAG node中
	src_root=u.find(src)
	dst_root=u.find(dst)

	if src_root==dst_root
		//如果这两个node已经在一个rag node中，就把他们忽略弹出去
		heapArray.pop()
	else
		//根据之前rag数据结构，计算src_root和dst_root融合之后的purity_loss
		purity_before=两个region合并之前histogram entropy的均值；
		newHist=两个bin为频率的histogram相加
		purity_after=entropy(newHist)
		purity_loss=purity_after-purity_before
		
		//如果当前heap顶部对应的edge weight需要update，则update，并且更新heap
		if purity_loss!=heapArray[0].weight:
			heapArray[0].weight=purity_loss
			heapArray=heapify(heapArray)
		else:
			rag.mergeNode(src_root,dst_root)
			superNum--
			heapArray.pop()
			u.union(src_root,dst_root)



RAG class
	addNode(ID,attribute)
		添加一个node，这个node有以下的attribue：
		pixelCount：记录这个node对应的superpixel region的pixel数量
		hist：一位数组，保存记录每个bin中pixel的数量


	addEdge(src,dst)
		1. 仅仅记录有一个那些src之间有edge就可以，edge的weight是在之后heap里面求的哲理不需要。
		2. 如果src，dst没有加入graph，这里还需要首先addNode()
		3. 无向图，所以src和dst上面都要存储adjacent list
	getNeighbor(ID)
		找到某个node周围所有的edge，对应的node ID
	mergeNode(src,dst)
		1. 新的node ID是dst的ID,src node删除
		2. 新node attribute更新，histogram，pixelCount，mergeList
		3. 集合运算，把list转换为set
			(1,2,4)|(1,3,5)-(3,4)=(1,2,5)
			1是3，4共有的neighbor，2是3独有的neighbor，5是4独有的
	？allEdge() 
		输出这个RAG的所有edge，因为我用的是无向图，所以每个edge在src，dst两个node上面都有存储，如果遍历输出就会有输出两个重复的edge，这个时候，可以overLoad Edge class的==运算，在

	constructRAG(slicLabel,fhLabel,img,binNum)
		for y from 0 to height
			for x from 0 to width
				右边edge
				//如果右边 pixel和当前pixel在一个slic region中
				if(slicLabel[y,x]==slicLabel[y,x+1])
					//如果右边pixel和当前
					if(fhLable[y,x]!=fhLabel[y,x+1])
						addEdge(fhLabel[y,x],fhLabel[y,x+1])
						//获得这个pixel应该放到histogram哪个bin中
						binIndex=histBin(img[y,x])
						//为了一次traverse就成功，所以定义一个bool的变量，记录这个pixel[y,x]是否已经在RAG对应node中更新
						if img[y,x]没有在RAG node中更新
							node[fhLabel[y,x]].histogram[binIndex]+=1
							node[fhLabel[y,x]].pixelCount+=1
						if img[y,x+1]没有在RAG node中更新
							更新fhLabel[y,x+1]对应RAG node的attribute

				同样方法处理：
				下边edge

				右上edge

				右下edge





Node class
	
	int [] histogram
		保存这个node的histogram，长度是bin^3，因为有3个chanel
	int pixelCount 





